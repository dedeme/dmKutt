// Copyright 05-Apr-2025 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Quotes table data

import "cts";

(quotes) [. [s][s][[f]][[f]][[f]][[f]]];

/// Constructor
///   Cos   : Company nicks.
///   Dates : Quotes dates in format YYYYMMDD, from before to after.
///   Opens : Array of normalized open quotes (without -1).
///           Its rows match 'dates' and its columns 'cos'.
///   Closes: Array of normalized close quotes (without -1).
///           Its rows match 'dates' and its columns 'cos'.
///   Maxs  : Array of normalized maximum quotes (without -1).
///           Its rows match 'dates' and its columns 'cos'.
///   Mins  : Array of normalized minimum quotes (without -1).
///           Its rows match 'dates' and its columns 'cos'.
//: [. [s][s][[f]][[f]][[f]][[f]]]
new : Cos, Dates, Opens, Closes, Maxs, Mins;

//: [(quotes)|s]
toJs = \o -> return js.wa([
    arr.toJs(o.Cos, js.ws),
    arr.toJs(o.Dates, js.ws),
    arr.toJs(o.Opens, \:arr row -> return row.toJs(js.wf);),
    arr.toJs(o.Closes, \:arr row -> return row.toJs(js.wf);),
    arr.toJs(o.Maxs, \:arr row -> return row.toJs(js.wf);),
    arr.toJs(o.Mins, \:arr row -> return row.toJs(js.wf);)
  ]);;

/// Returns the index of one company from its nick, or -1 if nick is not found.
//: [(quotes)s|i]
companyIndex = \qs, nick ->
  return arr.index(qs[Cos], \c -> return c == nick;);;

/// Extracts data of the company with index 'coIx'.
///   qs: All the quotes.
///   coIx: Index in qs.Cos of the company to extract.
//: [(quotes)i|(quotes)]
getSingle = \qs, coIx -> {
  Ds = qs[Dates];
  rows = arr.size(Ds);
  :arr AllOpens = qs.Opens;
  :arr AllCloses = qs.Closes;
  :arr AllMaxs = qs.Maxs;
  :arr AllMins = qs.Mins;

  Opens1 = arr.new([0.0], rows);
  Closes1 = arr.new([0.0], rows);
  Maxs1 = arr.new([0.0], rows);
  Mins1 = arr.new([0.0], rows);
  if (arr.size(AllOpens[0]) <= coIx)
    throw str.fmt("Companies number (%v) <= %v", [. arr.size(AllOpens[0]), coIx]);
  for (r = 0:rows) {
    Opens1.set(r, [AllOpens[r][coIx]]);
    Closes1.set(r, [AllCloses[r][coIx]]);
    Maxs1.set(r, [AllMaxs[r][coIx]]);
    Mins1.set(r, [AllMins[r][coIx]]);
  }
  return new([qs[Cos][coIx]], Ds, Opens1, Closes1, Maxs1, Mins1);
};

// Auxiliar function of 'read'.
_
//: [[s]s[s]|]
readDates = \:arr Dates, co, :arr Qs -> {
  for (i = 0:Qs.size()) {
    qdate = Qs.get(i)[:8];
    if (!math.isDigits(qdate))
      throw str.fmt("'%v'. Bad date in %v", [. qdate, co]);
    Dates.set(i, qdate);
  }
};

/// Read quotes4 of serveral companies.
///   dpath : Directory with files 'NICK'.tb.
///   Cos   : Nicks of companies to read.
//: [s[s]|(quotes)]
read = \dpath, :arr Cos -> {
  Dates = arr.new("", cts.historicQuotes);
  Qts = []/[[f]]/; // type x [days x cos]
  for (i = 0:4) {
    Days = []/[f]/;
    for (j = 0:cts.historicQuotes) Days.push(arr.new(0.0, Cos.size()));
    Qts.push(Days);
  }

  for (ico, co = Cos) {
    :file fpath = file.cat(dpath, [co + ".tb"]);
    :arr Qs = str.splitTrim(str.trim(fpath.read()), "\n");
    if (Qs.size() != cts.historicQuotes)
      throw str.fmt(
        "Dates of %v(%v) are different from %v",
        [. co, Qs.size(), cts.historicQuotes]
      );
    Qs.reverseIn();

    if (ico == 0) readDates(Dates, co, Qs);

    for (idate, qStr = Qs) {
      :arr Es = str.splitTrim(qStr, ":");
      if (Es.size() != 7)
        throw str.fmt(
          "Quote %v of %v has not 7 fields.", [. Qs[idate], co]
        );

      for (ie, :arr QQs = Qts) {
        q = Es.get(ie + 1);
        nOp = math.stof(q);
        if (!nOp)
          throw str.fmt(
            "Bad quote %v in %v of %v.", [. q, Qs[idate], co]
          );
        n = nOp!;

        if (n < 0.0 & idate > 0) {
          if (arr.get(QQs.get(idate - 1), ico) >= 0.0)
            arr.set(QQs.get(idate), ico, arr.get(QQs.get(idate - 1), ico));
          else
            arr.set(QQs.get(idate), ico, -1.0);
        } else {
          if (idate > 0 & arr.get(QQs.get(idate - 1), ico) < 0.0) {
            for (i = idate:0:-1)
              arr.set(QQs.get(i), ico, n);
          } else {
            arr.set(QQs.get(idate), ico, n);
          }
        }
      }
    }
  }

  return new(Cos, Dates, Qts[0], Qts[1], Qts[2], Qts[3]);
};
