// Copyright 06-Apr-2025 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Mix 'uudd0 - qfix'  model.

import "../model";
import "doc/uuqfDoc";

/// Returns a new 'uufq' model.
//: [|(model)]
new = \ -> return model.new(
    "SSQF",
    "Mix SSBB0 - QFIX",
    uuqfDoc.text,
    ["Inicio", "Cut"],
    [model.percParam, model.percParam]
  );;

/// Returns a new [. isSold, reference, closes array] of one company,
/// where:
/// state -> is true if the company is not in stock.
/// reference -> is the new company reference.
/// closes -> Closes used for calculating references.
///   Ref   : Reference data of previous calculus
///           ([. state, reference, closes array]).
///           'reference' is equals -1 when it is not fixed the initial one.
///   cl    : Current close.
///   Params: Model parameters.
//: [[. bf[f]]f[f] | [. bf[f]]]
ref = \Ref, cl, Params -> {
  start = Params[0];
  upStart = 1.0 + start;
  downStart = 1.0 - start;
  gap = Params[0] * Params[1];
  upGap = 1.0 + gap;

  isSold = Ref[0];
  rf = Ref[1];
  Cls = Ref[2];
  if (rf < 0.0) return [.
      false,
      cl / upGap,
      [cl, cl * downStart, cl / upGap, cl * (1.0 + upGap) / 2.0]
    ];

  prvC = Cls[0];
  rfU = Cls[1];
  rfQ = Cls[2];
  topQ = Cls[3];

  if (isSold) {
    if (cl > rfU | cl > rfQ) {
      rQ = cl / upGap;
      return [.
        false,
        rQ,
        [cl, cl * downStart, rQ, cl * (1.0 + upGap) / 2.0]
      ];
    } else {
      dif = cl - prvC;
      rfU0 = rfU * (prvC + dif) / prvC;
      rfU2 = rfU < rfU0 ? rfU : rfU0;
      rfQV = [. rfQ];
      topQV = [. topQ];
      while (cl < topQV!) {
        r0 = rfQV! / upGap;
        rfQV! = r0;
        r = r0 / upGap;
        topQV! = (r + r / upGap) / 2.0;
      }
      newRfQ = rfQV!;
      return [.
        true,
        rfU2 < newRfQ ? rfU2 : newRfQ,
        [cl, rfU2, newRfQ, topQV!]
      ];
    }
  } else {
    if (cl < rfU | cl < rfQ) {
      rQ = cl * upGap;
      return [.
        true,
        rQ,
        [cl, cl * upStart, rQ, (cl + cl / upGap) / 2.0]
      ];
    } else {
      dif = cl - prvC;
      rfU0 = rfU * (prvC + dif) / prvC;
      rfU2 = rfU > rfU0 ? rfU : rfU0;
      rfQV = [. rfQ];
      topQV = [. topQ];
      while (cl > topQV!) {
        r0 = rfQV! * upGap;
        rfQV! = r0;
        r = r0 * upGap;
        topQV! = r * (1.0 + upGap) / 2.0;
      }
      newRfQ = rfQV!;
      return [.
        false,
        rfU2 > newRfQ ? rfU2 : newRfQ,
        [cl, rfU2, newRfQ, topQV!]
      ];
    }
  }
};

//: [ [[f]][f] | [[f]] ]
refs = \:arr Closes, :arr Params -> {
  start = Params[0];
  upStart = 1.0 + start;
  downStart = 1.0 - start;
  gap = Params[0] * Params[1];
  upGap = 1.0 + gap;

  :arr Cls0 = Closes.get(0);
  ndates = Closes.size();
  ncos = Cls0.size();

  IsSolds = arr.new(false, ncos);

  RefUs = []/f/;
  RefQs = []/f/;
  TopQs = []/f/;
  for (cl = Cls0) {
    RefUs.push(cl * downStart);
    RefQs.push(cl / upGap);
    TopQs.push(cl * (1.0 + upGap) / 2.0);
  }

  RefQs2 = RefQs.copy();
  AllRefs = arr.new(RefQs2, ndates);
  for (idate = 1:ndates) {
    :arr ClosesR = Closes.get(idate);
    :arr PrvCloses = Closes.get(idate - 1);
    Refs = arr.new(0.0, ncos);

    for (ico = 0:ncos) {
      c = ClosesR.get(ico);
      prvC = PrvCloses.get(ico);
      rfU = RefUs.get(ico);
      rfQ = RefQs.get(ico);
      topQ = TopQs.get(ico);

      if (IsSolds.get(ico)) {
        if (c > rfU | c > rfQ) {
          IsSolds.set(ico,false);
          RefUs.set(ico,c * downStart);
          rQ = c / upGap;
          RefQs.set(ico,rQ);
          TopQs.set(ico,c * (1.0 + upGap) / 2.0);
          Refs.set(ico,rQ);
        } else {
          dif = c - prvC;
          rfU0 = rfU * (prvC + dif) / prvC;
          rfU2 = rfU < rfU0 ? rfU : rfU0;
          RefUs.set(ico,rfU2);

          rfQV = [. rfQ];
          topQV = [. topQ];
          while (c < topQV!) {
            r0 = rfQV! / upGap;
            rfQV! = r0;
            r = r0 / upGap;
            topQV! = (r + r / upGap) / 2.0;
          }
          newRfQ = rfQV!;
          RefQs.set(ico,newRfQ);
          TopQs.set(ico,topQV!);

          Refs.set(ico,rfU2 < newRfQ ? rfU2 : newRfQ);
        }
      } else {
        if (c < rfU | c < rfQ) {
          IsSolds.set(ico,true);
          RefUs.set(ico,c * upStart);
          rQ = c * upGap;
          RefQs.set(ico,rQ);
          TopQs.set(ico,(c + c / upGap) / 2.0);
          Refs.set(ico,rQ);
        } else {
          dif = c - prvC;
          rfU0 = rfU * (prvC + dif) / prvC;
          rfU2 = rfU > rfU0 ? rfU : rfU0;
          RefUs.set(ico,rfU2);

          rfQV = [. rfQ];
          topQV = [. topQ];
          while (c > topQV!) {
            r0 = rfQV! * upGap;
            rfQV! = r0;
            r = r0 * upGap;
            topQV! = r * (1.0 + upGap) / 2.0;
          }
          newRfQ = rfQV!;
          RefQs.set(ico, newRfQ);
          TopQs.set(ico, topQV!);

          Refs.set(ico,rfU2 > newRfQ ? rfU2 : newRfQ);
        }
      }
    }
    AllRefs.set(idate, Refs);
  }
  return AllRefs;
};
