// Copyright 05-Apr-2024 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Main charts page.

import "libdm/svrp";
import "libmkt/stRs";
import "libmkt/model";
import "libmkt/models";
import "libmkt/order";
import "libmkt/quotes";
import "libmkt/strategy";
import "libmkt/cts" : mcts;
import "extDb/cosTb";
import "extDb/quotesDb";
import "data/modelEval";
import "data/evE";
import "data/upRs";
import "fns";
import "cts";
import "db";

//: [{s}|s]
process = \:dic Rq -> {
  rq = js.rs(Rq\rq);
  switch (rq) {
    "idata": {
      mdId = js.rs(Rq\mdId);
      ixV = [js.ri(Rq\invIx)];
      :arr Es = db.read("daily", arr.peek(db.dates("daily")), mdId);
      eV = [Es[0]];
      if (ixV! < 0) {
        ixV! = 0;
        eV! = Es[0];
        for (i, :evE e = Es) {
          :upRs eavg = e.avg;
          if (eavg.sales < cts.minSales) continue; // Filter sales.
          :evE r = eV!;
          :upRs ravg = r.avg;
          if (eavg.pon > ravg.pon) {
            ixV! = i;
            eV! = e;
          }
        }
      } else {
        eV! = Es[ixV!];
      }
      ix = ixV!;
      Params = fns.ixToParams(mdId, ix);

      :evE ev = eV!;
      :upRs last = ev.eval;
      :upRs crr = ev.crr;
      mdEv = modelEval.new(crr.pon, crr.sales, last.pon, last.sales);
      :model md = models.get(mdId)!;
      Cos = cosTb.read();
      :quotes qts = quotesDb.read(Cos);
      Refs = md.refs(qts.Closes, Params);
      :stRs rs = strategy.open(md, qts, Refs);

      // only for calculating ponderation.
      :upRs invRs = upRs.new(
        0.0, // fake value
        arr.peek(rs.Hreals) / mcts.initialCapital,
        arr.peek(rs.Haccs) / mcts.initialCapital,
        1.0 + arr.reduce(rs.Profits, 0.0, \r, e -> return r + e;) /
            math.itof(arr.size(rs.Profits))
      );

      Dates = qts.Dates;
      CS = CoStates(Dates, rs.Orders);

      :arr Rs = js.ra(rs.toJs());
      Rs.unshift(arr.toJs(Refs, \Row -> return arr.toJs(Row, js.wf);));
      return svrp.mk({
        rs: js.wa(Rs),
        mdEv: arr.toJs([mdEv[0], mdEv[1], mdEv[2], mdEv[3]], js.wf),
        invIxFinal: js.wi(ixV!),
        pond: js.wf(invRs.pon),
        Closes: arr.toJs(qts.Closes, \Row -> return arr.toJs(Row, js.wf);),
        Dates: arr.toJs(Dates, js.ws),
        Cos: arr.toJs(Cos, js.ws),
        BuyCos: arr.toJs(CS\BuyCos, js.wi),
        QuarantineCos: arr.toJs(CS\QuarantineCos, js.wi)
      });
    }
    default: throw "Value of rq (" + rq + ") is not valid";
  }
};

//: [[s][(order)]|{[i]}]
CoStates = \:arr Dates, :arr Orders -> {
  dSize = Dates.size();
  oSize = Orders.size();

  Pf = {}/f/; // {nick -> price}
  BuyCos = arr.new(0, dSize);
  QuarantineCos = arr.new(0, dSize);
  if (!!Orders) {
    iOV = [0];
    :order o = Orders[iOV!];
    oV = [o];
    oDateV = [o.date];
    for (i, d = Dates) {
      while(oDateV! <= d & iOV! < oSize) {
        :order o = oV!;
        if (o.type == mcts.orderBuy) {
          dic.put(Pf, o.nick, o.price);
        } else {
          bprice = Pf[o.nick];
          dic.remove(Pf, o.nick);
          days = o.price >= bprice * mcts.noLossMultiplicator
            ? 0 :
            mcts.daysLoss
          ;
          end0 = i + days;
          end = end0 >= dSize ? dSize : end0;
          for (j = i:end) QuarantineCos[j] += 1;
        }
        iOV! += 1;
        if (iOV! < oSize) {
          :order o = Orders[iOV!];
          oV! = o;
          oDateV! = o.date;
        }
      }
      BuyCos[i] = dic.size(Pf);
    }
  }
  return {BuyCos, QuarantineCos};
};
