// Copyright 03-Oct-2025 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Investors table.

import "libmkt/cts" : mkCts;
import "irs";
import "cts";

(irsTable) [. [(irs)][i]];

/// Constructor. Do not use directly: use mk(Irss).
///   Irss: Table of results.
///   Ixs : Index from greater to lesser of field 'assets' in 'irs'.
/// NOTE: Irss and ix have the same number of elements.
//: [. [(irs)][i]]
new : Irss, Ixs;

/// Constructor
///   Irss: Table of results.
//: [[(irs)]|(irsTable)]
mk = \Irss -> {
  Ixs = []/[.i(irs)]/;
  for (i, iv = Irss) Ixs.push([. i, iv]);

  Ixs.sort(\E1, E2 -> {
    :irs i1 = E1[1];
    :irs i2 = E2[1];
    return i1.assets > i2.assets;
  });
  return [. Irss, Ixs.map(\E -> return E[0];)];
};

/// Returns the best value of 'this.Irss' whose number of sales
/// is >= cts.minSales.
//: [(irsTable)|(irs)]
best = \this -> {
  Irss = this.Irss;
  rOp = []/(irs)/;
  for (i = this.Ixs) {
    :irs r = Irss[i];
    if (r.yearSales() >= cts.minSales) {
      rOp.push(r);
      break;
    }
  }
  if (!rOp) throw("Every investor has sales < " + math.itos(cts.minSales));
  return rOp!;
};

//: [(irsTable)|s]
toJs = \o -> return js.wa([
    arr.toJs(o[Irss], irs.toJs),
    arr.toJs(o[Ixs], js.wi)
  ]);;


//: [s|(irsTable)]
fromJs = \j -> {
  A = js.ra(j);
  return [.
    arr.fromJs(A[0], irs.fromJs),
    arr.fromJs(A[1], js.ri)
  ];
};
